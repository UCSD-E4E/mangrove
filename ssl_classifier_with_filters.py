# -*- coding: utf-8 -*-
"""SSL Classifier with filters.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DPFf6Rab5EUPmSy7eQ7dKKNuS4fTTcMa
"""

from PIL import Image
import numpy as np
import os
import matplotlib.pyplot as plt
from skimage.color import rgb2gray
from sklearn.semi_supervised import LabelSpreading,LabelPropagation
import random
from sklearn import svm
from sklearn.kernel_approximation import Nystroem
from sklearn.ensemble import RandomForestClassifier
from sklearn import metrics
from sklearn.neural_network import MLPClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.gaussian_process import GaussianProcessClassifier
from sklearn.gaussian_process.kernels import RBF
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis
from skimage.filters import roberts,sobel, scharr, prewitt,gabor
import time
import cv2



def get_path_unlabelled_tiles(tilesDir,labelledTilesDir):
    path_of_unlabelled_tiles =[]
    tiles = []
    tile_names=[]
    for r, d, f in os.walk(tilesDir):
        for item in f:
            if '.tif' in item:
                tiles.append(os.path.join(r, item))
                tile_names.append(item)
    for index, tile in enumerate(tiles):
        labelled_raster_path = os.path.join(labelledTilesDir,"labelled_"+tile_names[index])
        if not (os.path.exists(labelled_raster_path)):
            path_of_unlabelled_tiles.append(tile)
    return  path_of_unlabelled_tiles 


def read_files(tilesDir,labelledTilesDir):
    tiles = []
    tile_names=[]
    for r, d, f in os.walk(tilesDir):
        for item in f:
            if '.tif' in item:
                tiles.append(os.path.join(r, item))
                tile_names.append(item)

    X_labelled=[] 
    X_unlabelled=[]
    Y_labelled=[]
    Y_unlabelled=[]
    #Read in the images 
    for index, tile in enumerate(tiles):
    
    
        labelled_raster_path = os.path.join(labelledTilesDir,"labelled_"+tile_names[index])
        if(os.path.exists(labelled_raster_path)):
            print("Procesing labelled tile...")
            lim = Image.open(labelled_raster_path)
            label = np.array(lim)
            alpha = label[:,:,3]
            r = label[:,:,0]
            alpha[alpha==255] = 1
            labels = alpha
            Y_labelled.append(labels)
        
            rim = Image.open(tile)
            raster = np.array(rim)[:,:,:3]    #It is a 4096x4096x3 image
            sobel_i = sobel_filtering(raster)  # Sobel filter
            roberts_i = roberts_filtering(raster) # roberts filter
            # prewitt_i = prewitt_filtering(raster)
            # scharr_i = scharr_filtering(raster)
            ret = gabor_filtering(raster) # set of images obtained from Gabor filter
            raster = cv2.cvtColor(raster, cv2.COLOR_BGR2HSV)  # Convert BGR to HSV 
            raster = np.dstack((raster,sobel_i)) 
            raster = np.dstack((raster,roberts_i))
            # raster = np.dstack((raster,prewitt_i))
            # raster = np.dstack((raster,scharr_i))
            for i in range(len(ret)):
              raster = np.dstack((raster,ret[i]))
            #gray = rgb2gray(raster)           #Converting the rgb to grayscale
            X_labelled.append(raster)
        else:
            rim = Image.open(tile)
            raster = np.array(rim)[:,:,:3]    #It is a 4096x4096x3 image
            #gray = rgb2gray(raster)           #Converting the rgb to grayscale
            sobel_i = sobel_filtering(raster)  # Sobel filter
            roberts_i = roberts_filtering(raster) # roberts filter
            # prewitt_i = prewitt_filtering(raster)
            # scharr_i = scharr_filtering(raster)
            ret = gabor_filtering(raster) # set of images obtained from Gabor filter
            raster = cv2.cvtColor(raster, cv2.COLOR_BGR2HSV)  # Convert BGR to HSV 
            raster = np.dstack((raster,sobel_i)) 
            raster = np.dstack((raster,roberts_i))
            # raster = np.dstack((raster,prewitt_i))
            # raster = np.dstack((raster,scharr_i))
            for i in range(len(ret)):
              raster = np.dstack((raster,ret[i]))
            X_unlabelled.append(raster)
            labels = np.full((4096, 4096), -1)
            Y_unlabelled.append(labels)
        
    X_labelled = np.asarray(X_labelled)
    Y_labelled = np.asarray(Y_labelled)
    X_unlabelled = np.asarray(X_unlabelled)
    Y_unlabelled = np.asarray(Y_unlabelled)

    # X_labelled = X_labelled.reshape(len(X_labelled)*X_labelled[0].shape[0]*X_labelled[0].shape[1],len(['R','G','B']))
    # Y_labelled = Y_labelled.reshape(len(Y_labelled)*Y_labelled[0].shape[0]*Y_labelled[0].shape[1],)
    # X_unlabelled = X_unlabelled.reshape(len(X_unlabelled)*X_unlabelled[0].shape[0]*X_unlabelled[0].shape[1],len(['R','G','B']))
    # Y_unlabelled = Y_unlabelled.reshape(len(Y_unlabelled)*Y_unlabelled[0].shape[0]*Y_unlabelled[0].shape[1],)
    X_labelled = X_labelled.reshape(len(X_labelled)*X_labelled[0].shape[0]*X_labelled[0].shape[1],10)
    Y_labelled = Y_labelled.reshape(len(Y_labelled)*Y_labelled[0].shape[0]*Y_labelled[0].shape[1],)
    X_unlabelled = X_unlabelled.reshape(len(X_unlabelled)*X_unlabelled[0].shape[0]*X_unlabelled[0].shape[1],10)
    Y_unlabelled = Y_unlabelled.reshape(len(Y_unlabelled)*Y_unlabelled[0].shape[0]*Y_unlabelled[0].shape[1],)

    return X_labelled,Y_labelled,X_unlabelled,Y_unlabelled
    
    

def prewitt_filtering(image):
    start_time = time.time()
    gray = rgb2gray(image)
    gray = prewitt(gray)
    print("time prewitt %s"%(time.time() - start_time))
    return gray


def gabor_filtering(image):
  start_time = time.time()
  image = rgb2gray(image)
  ret = []
  img = gabor(image,frequency = 0.6, theta = np.pi/4)
  ret.append(img[0])
  img = gabor(image,frequency = 0.6, theta = 0)
  ret.append(img[0])
  img = gabor(image,frequency = 0.6, theta = np.pi/2)
  ret.append(img[0])
  img = gabor(image,frequency = 0.6, theta = 3*np.pi/4)
  ret.append(img[0])
  img = gabor(image,frequency = 0.6, theta = np.pi)
  ret.append(img[0])
  return ret


def roberts_filtering(image):
    start_time = time.time()
    gray = rgb2gray(image)
    gray = roberts(gray)
    print("time roberts %s"%(time.time() - start_time))
    return gray


def scharr_filtering(image):
    start_time = time.time()
    gray = rgb2gray(image)
    gray = scharr(gray)
    print("time scharr %s"%(time.time() - start_time))
    return gray

def sobel_filtering(image):
    start_time = time.time()
    gray = rgb2gray(image)
    gray = sobel(gray)
    print("time sobel %s"%(time.time() - start_time))
    return gray



def check_number_distinct_labels(y):
    mangroves_index = np.where(y == 1)
    non_mangroves_index = np.where(y == 0)
    mangroves = len(mangroves_index[0])
    non_mangroves = len(non_mangroves_index[0])
    print("Number of mangrove pixels: ",mangroves)
    print("Number of non mangrove pixels: ",non_mangroves)
    return list(mangroves_index[0]),list(non_mangroves_index[0])




def get_random_points(mangroves_index,non_mangroves_index,length):
    random_mangroves_index = random.sample(mangroves_index, length)
    random_non_mangroves_index = random.sample(non_mangroves_index,length)
    return random_mangroves_index,random_non_mangroves_index


def form_training_sets(X,Y,random_mangroves_index,random_non_mangroves_index):
    X_t1 = list(X[random_mangroves_index])
    y_t1 = list(Y[random_mangroves_index])
    X_t2 =list(X[random_non_mangroves_index])
    y_t2 = list(Y[random_non_mangroves_index])
    return X_t1 + X_t2 , y_t1 + y_t2



def train_classifier(X,y,clf):
    clf.fit(X, y)
    return clf


def create_test_sets(X,Y):
    X_test=[]
    y_test=[]
    for i in range(len(X)-1, -1, -1):
        X_test.append(X[i])
        y_test.append(Y[i])
        if len(X_test) >=10000:
            break
    return X_test,y_test


def predict_labels(clf,X):
    return clf.predict(X)



    


if __name__ == "__main__":
    #Read the image files
    tilesDir  = "/content/drive/My Drive/Colab Notebooks/Tiles" 
    labelledTilesDir = "/content/drive/My Drive/Colab Notebooks/Labelled_Tiles"
    
    print("Reading the original tiles and the available labelled tiles....")
    X_labelled,Y_labelled,X_unlabelled,Y_unlabelled = read_files(tilesDir,labelledTilesDir)
    
    
    mangroves_index_labelled,non_mangroves_index_labelled = check_number_distinct_labels(Y_labelled)
    random_mangroves_index_labelled,random_non_mangroves_index_labelled = get_random_points(mangroves_index_labelled,non_mangroves_index_labelled,50000)
    
    classifiers = [
    #KNeighborsClassifier(3),
    #SVC(kernel="linear", C=0.025),
    #SVC(gamma=2, C=1),
    #GaussianProcessClassifier(1.0 * RBF(1.0)),
    #DecisionTreeClassifier(max_depth=5),
    RandomForestClassifier(max_depth=5, n_estimators=10),
    #MLPClassifier(alpha=1, max_iter=1000),
    #AdaBoostClassifier(),
    #GaussianNB(),
    #QuadraticDiscriminantAnalysis()
    ]
    
    for classifier in classifiers: 
        X_train,y_train = form_training_sets(X_labelled,Y_labelled,random_mangroves_index_labelled,random_non_mangroves_index_labelled)
        start = time.time()
        print("#"*50)
        print("#"*50)
        
        print("Fitting the ", classifier," classifier..........")
        clf = train_classifier(X_train,y_train,classifier)
        print("Predicting the labels for the unlabelled pixels....")
        y_unlabelled_pred = predict_labels(clf,X_unlabelled)
    
    
        print("Retraining the model with using the unlabelled data....")
        mangroves_index,non_mangroves_index = check_number_distinct_labels(y_unlabelled_pred)
        random_mangroves_index,random_non_mangroves_index = get_random_points(mangroves_index,non_mangroves_index,50000)
        X_train_unlabelled,y_train_unlabelled = form_training_sets(X_unlabelled,y_unlabelled_pred,random_mangroves_index,random_non_mangroves_index)
        X_train.extend(X_train_unlabelled)
        y_train.extend(y_train_unlabelled)
        clf = train_classifier(X_train,y_train,classifier)
    
        print("Testing the model.................")
        X_test,y_test = create_test_sets(X_labelled,Y_labelled)
        print("Performance on train sets...: ",clf.score(X_train, y_train))
        print("Performance of test sets of 10,000 samples:",metrics.accuracy_score(y_test, predict_labels(clf,X_test)))
        
        #Displaying the classified pixels.
        unlabelled_tiles = get_path_unlabelled_tiles(tilesDir,labelledTilesDir)
        for tile in unlabelled_tiles:
            X=[]
            im = np.array(Image.open(tile))[:,:,:3]
            sobel_im = sobel_filtering(im)  # Sobel filter
            roberts_im = roberts_filtering(im) # roberts filter
            ret_im = gabor_filtering(im) # set of images obtained from Gabor filter
            im = cv2.cvtColor(im, cv2.COLOR_BGR2HSV)  # Convert BGR to HSV 
            im = np.dstack((im,sobel_im)) 
            im = np.dstack((im,roberts_im))
            for i in range(len(ret_im)):
              im = np.dstack((im,ret_im[i]))
            X.append(im)
            X = np.asarray(X)
            X = X.reshape(len(X)*X[0].shape[0]*X[0].shape[1],10)
            y_pred = predict_labels(clf,X)
            y_pred = y_pred.reshape(im.shape[0],im.shape[1])
            image = Image.fromarray(y_pred * 255)
            image.show()
        
        
        end = time.time()
        print("The time elapsed for ",classifier,"classifier .........:",end - start)